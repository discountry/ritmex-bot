import type { MakerConfig } from '../config';
import { makeOrderPlan } from '../core/lib/order-plan';
import { safeCancelOrder } from '../core/lib/orders';
import { RateLimitController } from '../core/lib/rate-limit';
import { marketClose, placeOrder, unlockOperating } from '../core/order-coordinator';
import type { OrderLockMap, OrderPendingMap, OrderTimerMap } from '../core/order-coordinator';
import type { ExchangeAdapter } from '../exchanges/adapter';
import type { AsterAccountSnapshot, AsterDepth, AsterKline, AsterOrder, AsterTicker } from '../exchanges/types';
import { createTradeLog, type TradeLogEntry } from '../logging/trade-log';
import { isRateLimitError, isUnknownOrderError } from '../utils/errors';
import { formatPriceToString } from '../utils/math';
import { computePositionPnl } from '../utils/pnl';
import { getMidOrLast, getTopPrices } from '../utils/price';
import { shouldStopLoss } from '../utils/risk';
import { getPosition } from '../utils/strategy';
import type { PositionSnapshot } from '../utils/strategy';
import { StrategyEventEmitter } from './common/event-emitter';
import { SessionVolumeTracker } from './common/session-volume';
import { type LogHandler, safeSubscribe } from './common/subscriptions';

interface DesiredOrder {
   side: 'BUY' | 'SELL';
   price: string; // 改为字符串价格
   amount: number;
   reduceOnly: boolean;
}

export interface MakerEngineSnapshot {
   ready: boolean;
   symbol: string;
   topBid: number | null;
   topAsk: number | null;
   spread: number | null;
   position: PositionSnapshot;
   pnl: number;
   accountUnrealized: number;
   sessionVolume: number;
   openOrders: AsterOrder[];
   desiredOrders: DesiredOrder[];
   tradeLog: TradeLogEntry[];
   lastUpdated: number | null;
}

type MakerEvent = 'update';
type MakerListener = (snapshot: MakerEngineSnapshot) => void;

const EPS = 1e-5;

export class MakerEngine {
   private accountSnapshot: AsterAccountSnapshot | null = null;
   private depthSnapshot: AsterDepth | null = null;
   private tickerSnapshot: AsterTicker | null = null;
   private openOrders: AsterOrder[] = [];

   private readonly locks: OrderLockMap = {};
   private readonly timers: OrderTimerMap = {};
   private readonly pending: OrderPendingMap = {};
   private readonly pendingCancelOrders = new Set<string>();

   private readonly tradeLog: ReturnType<typeof createTradeLog>;
   private readonly events = new StrategyEventEmitter<MakerEvent, MakerEngineSnapshot>();
   private readonly sessionVolume = new SessionVolumeTracker();

   private timer: ReturnType<typeof setInterval> | null = null;
   private processing = false;
   private desiredOrders: DesiredOrder[] = [];
   private accountUnrealized = 0;
   private initialOrderSnapshotReady = false;
   private initialOrderResetDone = false;
   private entryPricePendingLogged = false;
   private readonly rateLimit: RateLimitController;

   constructor(private readonly config: MakerConfig, private readonly exchange: ExchangeAdapter) {
      this.tradeLog = createTradeLog(this.config.maxLogEntries);
      this.rateLimit = new RateLimitController(this.config.refreshIntervalMs, (type, detail) => this.tradeLog.push(type, detail));
      this.bootstrap();
   }

   start(): void {
      if (this.timer) { return; }
      this.timer = setInterval(() => {
         void this.tick();
      }, this.config.refreshIntervalMs);
   }

   stop(): void {
      if (this.timer) {
         clearInterval(this.timer);
         this.timer = null;
      }
   }

   on(event: MakerEvent, handler: MakerListener): void {
      this.events.on(event, handler);
   }

   off(event: MakerEvent, handler: MakerListener): void {
      this.events.off(event, handler);
   }

   getSnapshot(): MakerEngineSnapshot {
      return this.buildSnapshot();
   }

   private bootstrap(): void {
      const log: LogHandler = (type, detail) => this.tradeLog.push(type, detail);

      safeSubscribe<AsterAccountSnapshot>(
         this.exchange.watchAccount.bind(this.exchange),
         (snapshot) => {
            this.accountSnapshot = snapshot;
            const totalUnrealized = Number(snapshot.totalUnrealizedProfit ?? '0');
            if (Number.isFinite(totalUnrealized)) {
               this.accountUnrealized = totalUnrealized;
            }
            const position = getPosition(snapshot, this.config.symbol);
            this.sessionVolume.update(position, this.getReferencePrice());
            this.emitUpdate();
         },
         log,
         { subscribeFail: (error) => `订阅账户失败: ${String(error)}`, processFail: (error) => `账户推送处理异常: ${String(error)}` },
      );

      safeSubscribe<AsterOrder[]>(
         this.exchange.watchOrders.bind(this.exchange),
         (orders) => {
            this.syncLocksWithOrders(orders);
            this.openOrders = Array.isArray(orders) ? orders.filter((order) => order.type !== 'MARKET' && order.symbol === this.config.symbol) : [];
            const currentIds = new Set(this.openOrders.map((order) => String(order.orderId)));
            for (const id of Array.from(this.pendingCancelOrders)) {
               if (!currentIds.has(id)) {
                  this.pendingCancelOrders.delete(id);
               }
            }
            this.initialOrderSnapshotReady = true;
            this.emitUpdate();
         },
         log,
         { subscribeFail: (error) => `订阅订单失败: ${String(error)}`, processFail: (error) => `订单推送处理异常: ${String(error)}` },
      );

      safeSubscribe<AsterDepth>(
         this.exchange.watchDepth.bind(this.exchange, this.config.symbol),
         (depth) => {
            this.depthSnapshot = depth;
            this.emitUpdate();
         },
         log,
         { subscribeFail: (error) => `订阅深度失败: ${String(error)}`, processFail: (error) => `深度推送处理异常: ${String(error)}` },
      );

      safeSubscribe<AsterTicker>(
         this.exchange.watchTicker.bind(this.exchange, this.config.symbol),
         (ticker) => {
            this.tickerSnapshot = ticker;
            this.emitUpdate();
         },
         log,
         { subscribeFail: (error) => `订阅Ticker失败: ${String(error)}`, processFail: (error) => `价格推送处理异常: ${String(error)}` },
      );

      // Maker strategy does not consume klines, but subscribe to keep parity with other modules
      safeSubscribe<AsterKline[]>(
         this.exchange.watchKlines.bind(this.exchange, this.config.symbol, '1m'),
         (_klines) => {
            /* no-op */
         },
         log,
         { subscribeFail: (error) => `订阅K线失败: ${String(error)}`, processFail: (error) => `K线推送处理异常: ${String(error)}` },
      );
   }

   private syncLocksWithOrders(orders: AsterOrder[] | null | undefined): void {
      const list = Array.isArray(orders) ? orders : [];
      Object.keys(this.pending).forEach((type) => {
         const pendingId = this.pending[type];
         if (!pendingId) { return; }
         const match = list.find((order) => String(order.orderId) === pendingId);
         if (!match || (match.status && match.status !== 'NEW' && match.status !== 'PARTIALLY_FILLED')) {
            unlockOperating(this.locks, this.timers, this.pending, type);
         }
      });
   }

   private isReady(): boolean {
      return Boolean(this.accountSnapshot && this.depthSnapshot);
   }

   private async tick(): Promise<void> {
      if (this.processing) { return; }
      this.processing = true;
      let hadRateLimit = false;
      try {
         const decision = this.rateLimit.beforeCycle();
         if (decision === 'paused') {
            this.emitUpdate();
            return;
         }
         if (decision === 'skip') {
            return;
         }
         if (!this.isReady()) {
            this.emitUpdate();
            return;
         }
         if (!(await this.ensureStartupOrderReset())) {
            this.emitUpdate();
            return;
         }

         const depth = this.depthSnapshot!;
         const { topBid, topAsk } = getTopPrices(depth);
         if (topBid === null || topAsk === null) {
            this.emitUpdate();
            return;
         }

         // 直接使用orderbook价格，格式化为字符串避免精度问题
         const priceDecimals = Math.max(0, Math.floor(Math.log10(1 / this.config.priceTick)));
         const closeBidPrice = formatPriceToString(topBid, priceDecimals);
         const closeAskPrice = formatPriceToString(topAsk, priceDecimals);
         const bidPrice = formatPriceToString(topBid - this.config.bidOffset, priceDecimals);
         const askPrice = formatPriceToString(topAsk + this.config.askOffset, priceDecimals);
         const position = getPosition(this.accountSnapshot, this.config.symbol);
         const absPosition = Math.abs(position.positionAmt);
         const desired: DesiredOrder[] = [];
         const canEnter = !this.rateLimit.shouldBlockEntries();

         if (absPosition < EPS) {
            this.entryPricePendingLogged = false;
            if (canEnter) {
               desired.push({ side: 'BUY', price: bidPrice, amount: this.config.tradeAmount, reduceOnly: false });
               desired.push({ side: 'SELL', price: askPrice, amount: this.config.tradeAmount, reduceOnly: false });
            }
         } else {
            const closeSide: 'BUY' | 'SELL' = position.positionAmt > 0 ? 'SELL' : 'BUY';
            const closePrice = closeSide === 'SELL' ? closeAskPrice : closeBidPrice;
            desired.push({ side: closeSide, price: closePrice, amount: absPosition, reduceOnly: true });
         }

         this.desiredOrders = desired;
         this.sessionVolume.update(position, this.getReferencePrice());
         await this.syncOrders(desired);
         await this.checkRisk(position, Number(closeBidPrice), Number(closeAskPrice));
         this.emitUpdate();
      } catch (error) {
         if (isRateLimitError(error)) {
            hadRateLimit = true;
            this.rateLimit.registerRateLimit('maker');
            await this.enforceRateLimitStop();
            this.tradeLog.push('warn', `MakerEngine 429: ${String(error)}`);
         } else {
            this.tradeLog.push('error', `做市循环异常: ${String(error)}`);
         }
         this.emitUpdate();
      } finally {
         this.rateLimit.onCycleComplete(hadRateLimit);
         this.processing = false;
      }
   }

   private async enforceRateLimitStop(): Promise<void> {
      const position = getPosition(this.accountSnapshot, this.config.symbol);
      if (Math.abs(position.positionAmt) < EPS) { return; }
      const { topBid, topAsk } = getTopPrices(this.depthSnapshot);
      if (topBid === null || topAsk === null) { return; }
      const priceDecimals = Math.max(0, Math.floor(Math.log10(1 / this.config.priceTick)));
      const closeBidPrice = formatPriceToString(topBid, priceDecimals);
      const closeAskPrice = formatPriceToString(topAsk, priceDecimals);
      await this.checkRisk(position, Number(closeBidPrice), Number(closeAskPrice));
      await this.flushOrders();
   }

   private async ensureStartupOrderReset(): Promise<boolean> {
      if (this.initialOrderResetDone) { return true; }
      if (!this.initialOrderSnapshotReady) { return false; }
      if (!this.openOrders.length) {
         this.initialOrderResetDone = true;
         return true;
      }
      try {
         await this.exchange.cancelAllOrders({ symbol: this.config.symbol });
         this.pendingCancelOrders.clear();
         unlockOperating(this.locks, this.timers, this.pending, 'LIMIT');
         this.openOrders = [];
         this.emitUpdate();
         this.tradeLog.push('order', '启动时清理历史挂单');
         this.initialOrderResetDone = true;
         return true;
      } catch (error) {
         if (isUnknownOrderError(error)) {
            this.tradeLog.push('order', '历史挂单已消失，跳过启动清理');
            this.initialOrderResetDone = true;
            this.openOrders = [];
            this.emitUpdate();
            return true;
         }
         this.tradeLog.push('error', `启动撤单失败: ${String(error)}`);
         return false;
      }
   }

   private async syncOrders(targets: DesiredOrder[]): Promise<void> {
      const availableOrders = this.openOrders.filter((o) => !this.pendingCancelOrders.has(String(o.orderId)));
      const { toCancel, toPlace } = makeOrderPlan(availableOrders, targets);

      for (const order of toCancel) {
         if (this.pendingCancelOrders.has(String(order.orderId))) { continue; }
         this.pendingCancelOrders.add(String(order.orderId));
         await safeCancelOrder(this.exchange, this.config.symbol, order, () => {
            this.tradeLog.push('order', `撤销不匹配订单 ${order.side} @ ${order.price} reduceOnly=${order.reduceOnly}`);
         }, () => {
            this.tradeLog.push('order', '撤销时发现订单已被成交/取消，忽略');
            this.pendingCancelOrders.delete(String(order.orderId));
            this.openOrders = this.openOrders.filter((existing) => existing.orderId !== order.orderId);
         }, (error) => {
            this.tradeLog.push('error', `撤销订单失败: ${String(error)}`);
            this.pendingCancelOrders.delete(String(order.orderId));
            this.openOrders = this.openOrders.filter((existing) => existing.orderId !== order.orderId);
         });
      }

      for (const target of toPlace) {
         if (!target) { continue; }
         if (target.amount < EPS) { continue; }
         try {
            await placeOrder(
               this.exchange,
               this.config.symbol,
               this.openOrders,
               this.locks,
               this.timers,
               this.pending,
               target.side,
               target.price, // 已经是字符串价格
               target.amount,
               (type, detail) => this.tradeLog.push(type, detail),
               target.reduceOnly,
               { markPrice: getPosition(this.accountSnapshot, this.config.symbol).markPrice, maxPct: this.config.maxCloseSlippagePct },
               {
                  priceTick: this.config.priceTick,
                  qtyStep: 0.001, // 默认数量步长
               },
            );
         } catch (error) {
            this.tradeLog.push('error', `挂单失败(${target.side} ${target.price}): ${String(error)}`);
         }
      }
   }

   private async checkRisk(position: PositionSnapshot, bidPrice: number, askPrice: number): Promise<void> {
      const absPosition = Math.abs(position.positionAmt);
      if (absPosition < EPS) { return; }

      const hasEntryPrice = Number.isFinite(position.entryPrice) && Math.abs(position.entryPrice) > 1e-8;
      if (!hasEntryPrice) {
         if (!this.entryPricePendingLogged) {
            this.tradeLog.push('info', '做市持仓均价未同步，等待账户快照刷新后再执行止损判断');
            this.entryPricePendingLogged = true;
         }
         return;
      }
      this.entryPricePendingLogged = false;

      const pnl = computePositionPnl(position, bidPrice, askPrice);
      const triggerStop = shouldStopLoss(position, bidPrice, askPrice, this.config.lossLimit);

      if (triggerStop) {
         // 价格操纵保护：只有平仓方向价格与标记价格在阈值内才允许市价平仓
         const closeSideIsSell = position.positionAmt > 0;
         const closeSidePrice = closeSideIsSell ? bidPrice : askPrice;
         this.tradeLog.push('stop', `触发止损，方向=${position.positionAmt > 0 ? '多' : '空'} 当前亏损=${pnl.toFixed(4)} USDT`);
         try {
            await this.flushOrders();
            await marketClose(this.exchange, this.config.symbol, this.openOrders, this.locks, this.timers, this.pending, position.positionAmt > 0 ? 'SELL' : 'BUY', absPosition, (type, detail) => this.tradeLog.push(type, detail), {
               markPrice: position.markPrice,
               expectedPrice: Number(closeSidePrice) || null,
               maxPct: this.config.maxCloseSlippagePct,
            });
         } catch (error) {
            if (isUnknownOrderError(error)) {
               this.tradeLog.push('order', '止损平仓时订单已不存在');
            } else {
               this.tradeLog.push('error', `止损平仓失败: ${String(error)}`);
            }
         }
      }
   }

   private async flushOrders(): Promise<void> {
      if (!this.openOrders.length) { return; }
      for (const order of this.openOrders) {
         if (this.pendingCancelOrders.has(String(order.orderId))) { continue; }
         this.pendingCancelOrders.add(String(order.orderId));
         await safeCancelOrder(this.exchange, this.config.symbol, order, () => {
            // 成功撤销不记录日志，保持现有行为
         }, () => {
            this.tradeLog.push('order', '订单已不存在，撤销跳过');
            this.pendingCancelOrders.delete(String(order.orderId));
            this.openOrders = this.openOrders.filter((existing) => existing.orderId !== order.orderId);
         }, (error) => {
            this.tradeLog.push('error', `撤销订单失败: ${String(error)}`);
            this.pendingCancelOrders.delete(String(order.orderId));
            this.openOrders = this.openOrders.filter((existing) => existing.orderId !== order.orderId);
         });
      }
   }

   private emitUpdate(): void {
      try {
         const snapshot = this.buildSnapshot();
         this.events.emit('update', snapshot, (error) => {
            this.tradeLog.push('error', `更新回调处理异常: ${String(error)}`);
         });
      } catch (err) {
         this.tradeLog.push('error', `快照或更新分发异常: ${String(err)}`);
      }
   }

   private buildSnapshot(): MakerEngineSnapshot {
      const position = getPosition(this.accountSnapshot, this.config.symbol);
      const { topBid, topAsk } = getTopPrices(this.depthSnapshot);
      const spread = topBid !== null && topAsk !== null ? topAsk - topBid : null;
      const pnl = computePositionPnl(position, topBid, topAsk);

      return {
         ready: this.isReady(),
         symbol: this.config.symbol,
         topBid: topBid,
         topAsk: topAsk,
         spread,
         position,
         pnl,
         accountUnrealized: this.accountUnrealized,
         sessionVolume: this.sessionVolume.value,
         openOrders: this.openOrders,
         desiredOrders: this.desiredOrders,
         tradeLog: this.tradeLog.all(),
         lastUpdated: Date.now(),
      };
   }

   private getReferencePrice(): number | null {
      return getMidOrLast(this.depthSnapshot, this.tickerSnapshot);
   }
}
